---
layout: post
title: ES6学习笔记(变量的解构赋值)
date: 2016-01-25
categories: ES6
---

解构赋值这块，主要讲了数组，对象，字符串，数值和布尔值，函数参数这五类的解构赋值。

###1. 结构赋值的用途

首先，我们先不看具体的用法，来看看结构赋值会运用到哪些地方，先有一个大概的印象。

####交换变量的值

{% highlight JavaScript %}

[x, y] = [y, x];

{% endhighlight %}

如上代码，这样写交换变量，简洁易懂，语义清晰。

******

####从函数返回多个值

原来函数只能返回一个值，如果需要返回多个值需要把他们放到一个数组或者是对象里返回。有了解构赋值之后，一切就方便多了。

{% highlight JavaScript %}

// 返回一个数组

function example() {
  return [1, 2, 3];
}
var [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
var { foo, bar } = example();

{% endhighlight %}

******

####函数参数的定义

{% highlight JavaScript %}

// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3])

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1})

{% endhighlight %}

*******

####提取JSON数据

解构赋值对提取JSON对象中的数据，尤其有用。

{% highlight JavaScript %}

var jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
}

let { id, status, data: number } = jsonData;

console.log(id, status, number)
// 42, OK, [867, 5309]

{% endhighlight %}

*****

####函数参数的默认值

{% highlight JavaScript %}

jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
}) {
  // ... do stuff
};

{% endhighlight %}

可以指定参数的默认值，避免了在函数体当中写`var foo = config.foo || 'default foo';`这样的语句。

*****

####遍历Map结构

任何部署了Iterator接口的对象，都可以用`for...of`循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就很方便了。

{% highlight JavaScript %}

var map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world

{% endhighlight %}

如上，声明了两个变量`key`和`value`去接收了键值对。如果想只接收键名或者键值，可以运用如下写法。

{% highlight JavaScript %}

// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}

{% endhighlight %}

****

####输入模块的制定方法

加载模块时，往往需要制定输入哪些方法，解构赋值使得输入语句非常清晰。（我没懂。。。。）

{% highlight JavaScript %}

const { SourceMapConsumer, SourceNode } = require("source-map");

{% endhighlight %}

****

###2. 数组的解构赋值

####基本用法

按照一定的模式（格式），从数组和对象中取值来赋值给变量，这个过程被称为解构赋值。

以前，为变量赋值，只能是以下的形式：

{% highlight JavaScript %}

var a = 1;
var b = 2;
var c = 3;

{% endhighlight %}

而ES6允许以这种形式来赋值：

{% highlight JavaScript %}

var [a, b, c] = [1, 2, 3];

{% endhighlight %}

如上代码，等号两边可以按照对应位置，去对变量赋值。

这种写法属于“模式匹配”，只要等号两边的模式相同，右边的值就会赋给左边的变量中去。下面是一些解构的例子。

{% highlight JavaScript %}

let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []

{% endhighlight %}

如果解构不成功，变量的值就为`undefined`。

{% highlight JavaScript %}

var [foo] = [];
var [bar, foo] = [1];

{% endhighlight %}

还有一种情况是不完全解构，等号左边的模式只可以匹配到一部分等号右边的数组，这种情况依然可以解构成功。

如果等号的右边不是一个可以遍历的解构（[具体看这里](http://es6.ruanyifeng.com/#docs/iterator)），那么就会报错。

{% highlight JavaScript %}

// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};

{% endhighlight %}

上面的式子都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。

解构赋值不仅适用于`var`命令，也适用于`let`和`const`命令。对于Set解构，也可以使用数组的解构赋值。

{% highlight JavaScript %}

let [x, y, z] = new Set(["a", "b", "c"])
x // "a"

{% endhighlight %}

*****

####默认值

解构赋值允许指定默认值。

{% highlight JavaScript %}

var [foo = true] = [];
foo // true

[x, y = 'b'] = ['a'] // x='a', y='b'
[x, y = 'b'] = ['a', undefined] // x='a', y='b'

{% endhighlight %}

这里要注意的是，如果要使用默认的值，一定要严责等于`undefined`，否则默认值是不会生效的。

{% highlight JavaScript %}

var [x = 1] = [undefined];
x // 1

var [x = 1] = [null];
x // null

{% endhighlight %}

如上代码，如果等号右边是`null`的话，默认值就不会生效，因为`null`不严格等于`undefiend`。

默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

{% highlight JavaScript %}

let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError

{% endhighlight %}

如果代码，最后一个表达式报错是因为在`x`用到`y`时，`y`还没有声明。

******

###3. 对象的解构赋值

解构不仅可以用于数组，还可以用于对象。

{% highlight JavaScript %}

var { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"

{% endhighlight %}

